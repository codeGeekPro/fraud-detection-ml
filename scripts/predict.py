"""Script de pr√©diction en ligne de commande."""

import sys
import os
from pathlib import Path
import argparse
import logging
import json
from datetime import datetime
import warnings
warnings.filterwarnings('ignore')

# Ajout du chemin racine au sys.path
ROOT_DIR = Path(__file__).resolve().parent.parent
sys.path.append(str(ROOT_DIR))

# Imports de base
import numpy as np
import pandas as pd

# Imports locaux
from src.utils.helpers import setup_logging, load_config
from src.data.preprocessor import Preprocessor
from src.data.feature_engineer import FeatureEngineer

# Configuration du logging
logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s - %(name)s - %(levelname)s - %(message)s"
)
logger = logging.getLogger(__name__)


class FraudPredictor:
    """Classe pour effectuer des pr√©dictions de fraudes."""

    def __init__(self, config_path: str = "config/config.yaml"):
        """
        Initialise le pr√©dicteur de fraudes.

        Args:
            config_path (str): Chemin vers le fichier de configuration
        """
        self.config = load_config(config_path)
        self.logger = logger

        # Chargement du mod√®le
        self._load_model()

        # Chargement des composants de preprocessing
        self._load_preprocessing_components()

    def _load_model(self):
        """Charge le mod√®le entra√Æn√©."""
        import joblib

        # Recherche du mod√®le dans plusieurs emplacements possibles
        possible_paths = [
            "../models/trained/best_model.joblib",
            "../models/trained/best_model.pkl",
            "models/trained/best_model.joblib",
            "models/trained/best_model.pkl"
        ]
        
        model_path = None
        for path in possible_paths:
            if os.path.exists(path):
                model_path = path
                break
        
        if model_path:
            self.model = joblib.load(model_path)
            self.logger.info(f"‚úÖ Mod√®le charg√© avec succ√®s depuis {model_path}")
        else:
            raise FileNotFoundError(f"Mod√®le non trouv√©. Chemins essay√©s : {possible_paths}")

        # Chargement des m√©tadonn√©es
        metadata_paths = [
            "../models/metadata/model_metadata.json",
            "models/metadata/model_metadata.json"
        ]
        
        metadata_path = None
        for path in metadata_paths:
            if os.path.exists(path):
                metadata_path = path
                break
        
        if metadata_path:
            with open(metadata_path, 'r') as f:
                self.metadata = json.load(f)
            self.logger.info("‚úÖ M√©tadonn√©es charg√©es")
        else:
            self.metadata = {}
            self.logger.warning("‚ö†Ô∏è M√©tadonn√©es non trouv√©es")

    def _load_preprocessing_components(self):
        """Charge les composants de preprocessing."""
        # Chargement des donn√©es d'entra√Ænement pour fitter les transformeurs
        from src.data.data_loader import DataLoader

        data_loader = DataLoader()
        df = data_loader.load_data(file_path="../data/raw/creditcard.csv")

        # Initialisation du preprocessor
        self.preprocessor = Preprocessor({
            'missing_values_strategy': 'median',
            'scaling_method': 'standard'
        })

        # Fit du preprocessor (exclut automatiquement la colonne Class)
        self.preprocessor.fit(df)

        # Initialisation du feature engineer
        self.feature_engineer = FeatureEngineer()

        # Fit du feature engineer
        df_prep = self.preprocessor.transform(df)
        self.feature_engineer.fit(df_prep)

        self.logger.info("‚úÖ Composants de preprocessing charg√©s")

    def _validate_input(self, transaction_data: dict) -> pd.DataFrame:
        """
        Valide et pr√©pare les donn√©es d'entr√©e.

        Args:
            transaction_data (dict): Donn√©es de la transaction

        Returns:
            pd.DataFrame: Donn√©es valid√©es et pr√©par√©es
        """
        required_features = [
            'Time', 'V1', 'V2', 'V3', 'V4', 'V5', 'V6', 'V7', 'V8', 'V9', 'V10',
            'V11', 'V12', 'V13', 'V14', 'V15', 'V16', 'V17', 'V18', 'V19', 'V20',
            'V21', 'V22', 'V23', 'V24', 'V25', 'V26', 'V27', 'V28', 'Amount'
        ]

        # V√©rification des features requises
        missing_features = [f for f in required_features if f not in transaction_data]
        if missing_features:
            raise ValueError(f"Features manquantes : {missing_features}")

        # Conversion en DataFrame
        df = pd.DataFrame([transaction_data])

        # Validation des types de donn√©es
        numeric_features = required_features
        for feature in numeric_features:
            try:
                df[feature] = pd.to_numeric(df[feature], errors='coerce')
            except:
                raise ValueError(f"Feature {feature} doit √™tre num√©rique")

        # V√©rification des valeurs manquantes
        if df.isnull().any().any():
            raise ValueError("Les donn√©es contiennent des valeurs manquantes")

        return df

    def predict_single(self, transaction_data: dict, threshold: float = 0.5) -> dict:
        """
        Effectue une pr√©diction pour une seule transaction.

        Args:
            transaction_data (dict): Donn√©es de la transaction
            threshold (float): Seuil de d√©cision

        Returns:
            dict: R√©sultats de la pr√©diction
        """
        self.logger.info("üîÑ Pr√©diction en cours...")

        # Validation et pr√©paration des donn√©es
        df_input = self._validate_input(transaction_data)

        # Application du preprocessing
        df_prep = self.preprocessor.transform(df_input)

        # Application du feature engineering
        df_features = self.feature_engineer.transform(df_prep)

        # Suppression de la colonne Class si elle existe
        if 'Class' in df_features.columns:
            df_features = df_features.drop('Class', axis=1)

        # Pr√©diction
        prediction_proba = self.model.predict_proba(df_features)[0]
        prediction = (prediction_proba[1] >= threshold).astype(int)

        # R√©sultats d√©taill√©s
        result = {
            'prediction': int(prediction),
            'prediction_proba': {
                'fraud': float(prediction_proba[1]),
                'legitimate': float(prediction_proba[0])
            },
            'threshold_used': threshold,
            'is_fraud': bool(prediction),
            'confidence': float(max(prediction_proba)),
            'risk_level': self._get_risk_level(prediction_proba[1]),
            'timestamp': datetime.now().isoformat(),
            'model_info': {
                'name': self.metadata.get('model_name', 'Unknown'),
                'version': self.metadata.get('version', 'Unknown')
            }
        }

        self.logger.info(f"‚úÖ Pr√©diction termin√©e : {'FRAUDE' if prediction else 'L√âGITIME'} "
                        f"(probabilit√© : {prediction_proba[1]:.4f})")

        return result

    def _get_risk_level(self, fraud_probability: float) -> str:
        """
        D√©termine le niveau de risque bas√© sur la probabilit√© de fraude.

        Args:
            fraud_probability (float): Probabilit√© de fraude

        Returns:
            str: Niveau de risque
        """
        if fraud_probability >= 0.8:
            return "TR√àS √âLEV√â"
        elif fraud_probability >= 0.6:
            return "√âLEV√â"
        elif fraud_probability >= 0.4:
            return "MOYEN"
        elif fraud_probability >= 0.2:
            return "FAIBLE"
        else:
            return "TR√àS FAIBLE"

    def predict_batch(self, transactions_data: list, threshold: float = 0.5) -> list:
        """
        Effectue des pr√©dictions pour un lot de transactions.

        Args:
            transactions_data (list): Liste des donn√©es de transactions
            threshold (float): Seuil de d√©cision

        Returns:
            list: Liste des r√©sultats de pr√©diction
        """
        self.logger.info(f"üîÑ Pr√©diction par lot : {len(transactions_data)} transactions")

        results = []
        for i, transaction in enumerate(transactions_data):
            try:
                result = self.predict_single(transaction, threshold)
                result['transaction_id'] = i
                results.append(result)
            except Exception as e:
                self.logger.error(f"Erreur pour la transaction {i} : {str(e)}")
                results.append({
                    'transaction_id': i,
                    'error': str(e),
                    'timestamp': datetime.now().isoformat()
                })

        self.logger.info(f"‚úÖ Pr√©diction par lot termin√©e : {len(results)} r√©sultats")
        return results

    def save_prediction(self, result: dict, output_path: str = None):
        """
        Sauvegarde le r√©sultat de pr√©diction.

        Args:
            result (dict): R√©sultat de la pr√©diction
            output_path (str): Chemin de sauvegarde
        """
        if output_path is None:
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            output_path = f"../reports/prediction_{timestamp}.json"

        os.makedirs(os.path.dirname(output_path), exist_ok=True)

        with open(output_path, 'w') as f:
            json.dump(result, f, indent=2, default=str)

        self.logger.info(f"üíæ Pr√©diction sauvegard√©e : {output_path}")


def create_sample_transaction() -> dict:
    """Cr√©e un exemple de transaction pour les tests."""
    return {
        "Time": 123456.0,
        "V1": -1.3598071336738,
        "V2": -0.0727811733098497,
        "V3": 2.53634673796914,
        "V4": 1.37815522427443,
        "V5": -0.338320769942518,
        "V6": 0.462387777762292,
        "V7": 0.239598554061257,
        "V8": 0.0986979012610507,
        "V9": 0.363786969611213,
        "V10": 0.0907941719789316,
        "V11": -0.551599533260813,
        "V12": -0.617800855762348,
        "V13": -0.991389847235408,
        "V14": -0.311169353699879,
        "V15": 1.46817697209427,
        "V16": -0.470400525259478,
        "V17": 0.207971241929242,
        "V18": 0.0257905801985591,
        "V19": 0.403992960255733,
        "V20": 0.251412098239705,
        "V21": -0.018306777944153,
        "V22": 0.277837575558899,
        "V23": -0.110473910188767,
        "V24": 0.0669280749146731,
        "V25": 0.128539358273528,
        "V26": -0.189114843888824,
        "V27": 0.133558376740387,
        "V28": -0.0210530534538215,
        "Amount": 149.62
    }


def main():
    """Point d'entr√©e principal pour les pr√©dictions."""
    parser = argparse.ArgumentParser(
        description="Pr√©diction de fraudes pour transactions individuelles ou par lot",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
EXEMPLES D'UTILISATION :

1. Pr√©diction pour une transaction depuis un fichier JSON :
   python predict.py --input transaction.json

2. Pr√©diction pour une transaction depuis la ligne de commande :
   python predict.py --features "Time=123456,V1=-1.35,V2=-0.07,Amount=149.62"

3. Pr√©diction par lot :
   python predict.py --batch transactions.json

4. Utilisation d'un seuil personnalis√© :
   python predict.py --input transaction.json --threshold 0.3

5. G√©n√©ration d'un exemple de transaction :
   python predict.py --sample
        """
    )

    parser.add_argument("--config", default="../config/config.yaml",
                       help="Chemin vers le fichier de configuration")
    parser.add_argument("--input", "-i", type=str,
                       help="Fichier JSON contenant les donn√©es de transaction")
    parser.add_argument("--batch", "-b", type=str,
                       help="Fichier JSON contenant un lot de transactions")
    parser.add_argument("--features", "-f", type=str,
                       help="Features sous forme cl√©=valeur s√©par√©es par des virgules")
    parser.add_argument("--threshold", "-t", type=float, default=0.5,
                       help="Seuil de d√©cision (d√©faut: 0.5)")
    parser.add_argument("--output", "-o", type=str,
                       help="Fichier de sortie pour les r√©sultats")
    parser.add_argument("--sample", action="store_true",
                       help="G√©n√®re un exemple de transaction")
    parser.add_argument("--verbose", "-v", action="store_true",
                       help="Mode verbose")

    args = parser.parse_args()

    # Configuration du logging
    if args.verbose:
        logging.getLogger().setLevel(logging.DEBUG)

    try:
        # G√©n√©ration d'exemple
        if args.sample:
            sample = create_sample_transaction()
            print("EXEMPLE DE TRANSACTION :")
            print(json.dumps(sample, indent=2))
            return

        # Initialisation du pr√©dicteur
        predictor = FraudPredictor(args.config)

        # Pr√©diction depuis fichier
        if args.input:
            with open(args.input, 'r') as f:
                transaction_data = json.load(f)
            result = predictor.predict_single(transaction_data, args.threshold)

        # Pr√©diction par lot
        elif args.batch:
            with open(args.batch, 'r') as f:
                transactions_data = json.load(f)
            result = predictor.predict_batch(transactions_data, args.threshold)

        # Pr√©diction depuis ligne de commande
        elif args.features:
            # Parsing des features
            features_dict = {}
            for pair in args.features.split(','):
                key, value = pair.split('=')
                features_dict[key.strip()] = float(value.strip())
            result = predictor.predict_single(features_dict, args.threshold)

        else:
            parser.print_help()
            return

        # Affichage des r√©sultats
        if isinstance(result, list):
            # R√©sultats par lot
            print(f"\nüìä R√âSULTATS DE PR√âDICTION PAR LOT ({len(result)} transactions) :\n")
            fraud_count = sum(1 for r in result if r.get('is_fraud', False))
            print(f"üîç Transactions frauduleuses d√©tect√©es : {fraud_count}")
            print(f"‚úÖ Transactions l√©gitimes : {len(result) - fraud_count}")

            # Affichage d√©taill√© des fraudes
            if fraud_count > 0:
                print("\nüö® TRANSACTIONS SUSPECTES :")
                for r in result:
                    if r.get('is_fraud', False):
                        print(f"  ‚Ä¢ Transaction {r['transaction_id']}: "
                              f"Probabilit√© = {r['prediction_proba']['fraud']:.4f}, "
                              f"Risque = {r['risk_level']}")

        else:
            # R√©sultat unique
            print("\nüìä R√âSULTAT DE PR√âDICTION :")
            print(f"üîç Pr√©diction : {'üö® FRAUDE' if result['is_fraud'] else '‚úÖ L√âGITIME'}")
            print(f"üìà Probabilit√© de fraude : {result['prediction_proba']['fraud']:.4f}")
            print(f"üéØ Confiance : {result['confidence']:.4f}")
            print(f"‚ö†Ô∏è Niveau de risque : {result['risk_level']}")
            print(f"üìè Seuil utilis√© : {result['threshold_used']}")

        # Sauvegarde si demand√©
        if args.output:
            predictor.save_prediction(result, args.output)

        print("\nüéâ PR√âDICTION TERMIN√âE AVEC SUCC√àS !")
    except Exception as e:
        logger.error(f"‚ùå Erreur lors de la pr√©diction : {str(e)}")
        raise


if __name__ == "__main__":
    main()
